return getIscritti().stream().filter(q -> !(q.getId().equals(pName))).filter(q -> verificaSesso(q, pPref))
				.map(q -> calcolaCorrispondenza(q, pPref, pName)).collect(Collectors.toCollection(TreeSet::new));

return List.of(indexRange, indexSegno, indexLoc, indexAltezza, indexPeso, indexColoreCapelli, indexColoreOcchi)
				.stream().min(Comparator.comparing(Integer::valueOf)).get();

private String calcolaPercentuali(Elezioni elezioni) {
		StringBuilder sb = new StringBuilder();
		Partito[] partiti = elezioni.getPartiti().toArray(new Partito[1]);
		List<Long> listaVoti = Arrays.stream(partiti).map(elezioni::getVoti).collect(Collectors.toList());
		Long totaleVoti = Arrays.stream(partiti).mapToLong(elezioni::getVoti).sum();
		List<Double> listaPercVoti = listaVoti.stream().map(v-> v.doubleValue()/totaleVoti).collect(Collectors.toList());
		List<Long> listaSeggi = elezioni.getRisultato().getPartiti().stream().map(elezioni.getRisultato()::getSeggi).collect(Collectors.toList());
		List<Double> listaPercSeggi = listaSeggi.stream().map(v-> v.doubleValue()/elezioni.getSeggiDaAssegnare()).collect(Collectors.toList());
		NumberFormat formatter = NumberFormat.getPercentInstance(Locale.ITALY);
		for (int i=0; i< partiti.length; i++) {
			sb.append(String.format("%-35.35s %5s %4s %15s %3s%n", 
					partiti[i], "Voti%:",
					formatter.format(listaPercVoti.get(i)), "Seggi%:", formatter.format(listaPercSeggi.get(i))));
		}
		return sb.toString();
	}

usando map e poi to list, la mappatura mantiene l'ordine, 
perÃ² devi conoscere l'ordine iniziale, quindi partire da una lista o da un array

se ti da problemi usato gli stream di wrapper
.boxed().collect(Collectors.toList());

invece di mapToDouble puoi fare a.doubleValue